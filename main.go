package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
)

const (
	fileHeader = `
// DO NOT EDIT THIS FILE
// This file was generated automatically
// Simply run ` + "`" + `go generate` + "`" + ` in this directory to regenerate

package res

import (
	"fmt"
	"html/template"
)

var (
	Template = template.New("")
	Styles = make(map[string][]byte)
	HTML = make(map[string][]byte)
	Scripts = make(map[string][]byte)
)

func genInit() {
	var err error
	_ = fmt.Sprintf("%v", err) // suppress unused import error
`
	templateDecl = `
	_, err = Template.Parse(%#[2]v)
	if err != nil {
		panic(fmt.Sprintf("error parsing %[1]s - %%v", err))
	}
`
	styleDecl = `
	Styles[%#v] = %#v
`
	htmlDecl = `
	HTML[%#v] = %#v
`
	scriptDecl = `
	Scripts[%#v] = %#v
`
	fileFooter = `
}
// end of generated file
`
)

var (
	outFile     *os.File
	dataDir     string
	resFileName string
)

func panicIf(err error) {
	if err != nil {
		panic(err)
	}
}

func genGoFile(fPath string, info os.FileInfo, err error) error {
	panicIf(err)
	if info.IsDir() {
		return nil
	}
	var normPath string
	if !flatDir {
		normPath, err = filepath.Rel(dataDir, fPath)
	} else {
		normPath = filepath.Base(fPath)
	}
	panicIf(err)
	b, err := ioutil.ReadFile(fPath)
	panicIf(err)
	switch filepath.Ext(normPath) {
	case ".tmpl":
		fmt.Fprintf(outFile, templateDecl, normPath, string(b))
	case ".css":
		fmt.Fprintf(outFile, styleDecl, normPath, b)
	case ".html":
		fmt.Fprintf(outFile, htmlDecl, normPath, b)
	case ".js":
		fmt.Fprintf(outFile, scriptDecl, normPath, b)
	}
	return nil
}

var (
	flatDir bool
)

func init() {
	flag.BoolVar(&flatDir, "flat", false, "Resources are identfied by their filenames only. Directory structure is ignored.")
	flag.Parse()
	dataDir = flag.Arg(0)
	resFileName = flag.Arg(1)
}

func main() {
	const outFileFlags = os.O_CREATE | os.O_WRONLY | os.O_TRUNC
	var err error
	outFile, err = os.OpenFile(resFileName, outFileFlags, 0660)
	panicIf(err)
	defer outFile.Close()
	fmt.Fprint(outFile, fileHeader)
	err = filepath.Walk(dataDir, genGoFile)
	panicIf(err)
	fmt.Fprint(outFile, fileFooter)
}
